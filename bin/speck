#!/usr/bin/env bash

## For tests with Bash 3 on MacOS.
#!/bin/bash

set -e ## errexit
set -u ## nounset

IFS='
'
SpeckCmdDir="$(cd "$(dirname "$0")" && pwd)"
VerboseFlag=no
DebugFlag=no
MessageBuffer=
ProgressBuffer=

: ${ResetStyle:=$(tput sgr0)}
: ${BoldStyle:=$(tput bold)}
: ${ReverseStyle:=$(tput rev)}

: ${GreenStyle:=$(tput setaf 120)}
: ${YellowStyle:=$(tput setaf 229)}
: ${RedStyle:=$(tput setaf 160)}
: ${BlueStyle:=$(tput setaf 75)}
: ${GrayStyle:=$(tput setaf 239)}

if test $(tput colors) -le 8; then
        GreenStyle="$(tput setaf 2)"
        YellowStyle="$(tput setaf 3)"
        RedStyle="$(tput setaf 1)"
        BlueStyle="$(tput setaf 4)"
        GrayStyle="$(tput setaf 8)"
fi

if test ! -t 1 -o -p /dev/stdout; then
        ## We are redirected or in a pipe.
        ResetStyle=
        ReverseStyle=
        GreenStyle=
        YellowStyle=
        RedStyle=
        BlueStyle=
        GrayStyle=
fi

ErrorStyle="$RedStyle"
WarningStyle="$YellowStyle"
SuccessStyle="$GreenStyle"
DimmedStyle="$GrayStyle"

: ${SpeckSuiteStyle:=\\n%s\\n}
: ${SpeckProgressStyle:=${ReverseStyle} suites(\{suites_count\}/\{suites_total\}) specs(\{specs_count\}/\{specs_total\}) checks(\{checks_count\}/\{checks_total\}) ${ResetStyle}}
: ${SpeckCheckProgressStyle:=          \{desc\}}
: ${SpeckCheckSuccessStyle:=    ${SuccessStyle}ok${ResetStyle}    \{desc\}}
: ${SpeckCheckErrorStyle:=  ${ErrorStyle}failed${ResetStyle}  \{desc\}}
: ${SpeckSuccessStyle:=\\n${SuccessStyle}${ReverseStyle} Success ${ResetStyle}  }
: ${SpeckErrorStyle:=\\n${ErrorStyle}${ReverseStyle} Error ${ResetStyle}  }
: ${SpeckDumpStyle:=s:^:> :}
: ${SpeckSummaryStyle:=failed(${ErrorStyle}${BoldStyle}\{errors\}${ResetStyle})  succeeded(${SuccessStyle}${BoldStyle}\{completed\}${ResetStyle})  total(${BlueStyle}${BoldStyle}\{specs\}${ResetStyle})\\n}

before_all() { :; }
before()     { :; }
after()      { :; }
after_all()  { :; }

main()
{
        while test $# -gt 0; do
                case $1 in
                        -v|--verbose) VerboseFlag=yes; shift;;
                        -d|--debug) DebugFlag=yes; shift;;
                        --) shift; break;;
                        -*) usage; exit 1;;
                        *) break;;
                esac
        done

        if test "$DebugFlag" = 'yes'; then
                set -x ## xtrace
        fi

        if test $# -eq 0; then
                while read -r dir; do
                        if test -e "$dir"; then
                                set -- "$dir"
                                break
                        fi
                done <<EOF
$PWD/spec
$PWD/specs
$PWD/test
$PWD/tests
$SpeckCmdDir/spec
$SpeckCmdDir/specs
$SpeckCmdDir/test
$SpeckCmdDir/tests
EOF
        fi

        run_suites "$@"
}

usage()
{
        echo "Usage: $(basename "$0") [ -v,--verbose ] [ -d,--debug ] [ <file_or_dir> ... ]"
}

clean()
{
        test ! -e "$MessageBuffer" || rm -f "$MessageBuffer"
        test ! -e "$ProgressBuffer" || rm -f "$ProgressBuffer"
}

run_suites()
{
        MessageBuffer="$(mktemp)"
        ProgressBuffer="$(mktemp)"

        local plan=''
        local exit_status=0
        local suites_total=$#
        local specs_total=0
        local checks_total=0
        local suites_count=0
        local specs_count=0
        local checks_count=0

        for suite; do
                local suite_dir="${suite%/}"

                ## Workaround for a Bash 3 bug that prevents 'cd dir'
                ## when 'dir' is not written as './dir'.
                case "$suite_dir" in
                          /*) ;;
                          *) suite_dir="$PWD/$suite_dir";;
                esac

                ## Normalizes a path (with ..).
                suite_dir="$(cd "$suite_dir" && pwd)"

                local specs_files="$(find -L "$suite_dir" -type f -maxdepth 2 | grep -E '_(spec|test).sh$' | sort -n)"
                specs_total=$(expr $specs_total + $(count_lines "$specs_files") || true)

                for spec_file in $specs_files; do
                        local spec_checks="$(grep -Eo '^(it|test)[_[:alnum:]]+\(\)' "$spec_file")"
                        checks_total=$(expr $checks_total + $(count_lines "$spec_checks") || true)

                        plan="${plan}\
suite:$suite_dir
spec:$spec_file
checks:$(printf -- '%s' "$spec_checks" | tr '\n' ' ')
" ## We need a new line at the end for 'read' to process it.
                done
        done

        local prev_suite=
        local prev_spec=
        local suite=
        local spec=
        local checks=
        local line_count=0
        for line in $plan; do
                line_count=$(expr $line_count + 1)

                case $line_count in
                        1) suite="${line#*:}"; continue;;
                        2) spec="${line#*:}"; continue;;
                        3) checks="${line#*:}"; line_count=0;;
                esac

                if test "$prev_suite" != "$suite"; then
                        suites_count=$(expr $suites_count + 1)
                fi

                if test "$prev_spec" != "$spec"; then
                        specs_count=$(expr $specs_count + 1)
                fi

                checks="$(printf -- '%s' "$checks" | tr ' ' '\n')"

                set +e
                run_spec "$suite" "$spec" "$checks"
                exit_status="$(expr $exit_status + $? || true)"
                set -e

                checks_count=$(expr $checks_count + $(count_lines "$checks"))

                prev_suite="$suite"
                prev_spec="$spec"
        done

        if test $exit_status -eq 0; then
                printf -- "$SpeckSuccessStyle"
        else
                printf -- "$SpeckErrorStyle"
        fi

        printf -- "$SpeckSummaryStyle" \
        | sed -e "s:{errors}:$exit_status:g" \
              -e "s:{completed}:$(expr $checks_count - $exit_status || true):g" \
              -e "s:{specs}:$checks_count:g"

        clean

        return $exit_status
}

run_spec()
{(
        set -e

        local suite="$1"
        local spec_file="$2"
        local spec_checks="$3"
        local spec_exit_status=0

        printf -- "$SpeckSuiteStyle" "${spec_file#$suite/}" \
        | output

        __specdir__="$(dirname "$spec_file")"
        __specfile__="$spec_file"

        . "$spec_file"

        before_all

        for spec_check in $spec_checks; do
                checks_count=$(expr $checks_count + 1)
                local spec_check_name="${spec_check%%\(*}"
                local spec_check_desc="$(printf -- '%s' "$spec_check_name" | tr '_' ' ')"

                set +e
                (
                set -e

                before

                printf -- "$SpeckCheckProgressStyle" \
                | sed -e "s:{desc}:$spec_check_desc:g" \
                | output

                set +e
                output="$(set -e; $spec_check_name 2>&1)"
                test $? -eq 0   ## Converts an exit status different from 0 to 1.
                local spec_check_exit_status=$?
                set -e

                local speck_check_style="$SpeckCheckErrorStyle"
                if test $spec_check_exit_status -eq 0; then
                        speck_check_style="$SpeckCheckSuccessStyle"
                fi

                printf -- "$(tput cuu1)$speck_check_style$(tput el)" \
                | sed -e "s:{desc}:$spec_check_desc:g" \
                | output

                if test -n "$output" -a "$VerboseFlag" = 'yes'; then
                        cat <<OUT | sed -e "$SpeckDumpStyle" | output
$output
OUT
                fi

                after

                return $spec_check_exit_status
                )

                spec_exit_status=$(expr $spec_exit_status + $? || true)
        done

        after_all

        return $spec_exit_status
)}

output()
{
        cat >> "$MessageBuffer"

        printf -- "$SpeckProgressStyle" \
        | sed -e "s:{suites_count}:$suites_count:g" \
              -e "s:{suites_total}:$suites_total:g" \
              -e "s:{specs_count}:$specs_count:g" \
              -e "s:{specs_total}:$specs_total:g" \
              -e "s:{checks_count}:$checks_count:g" \
              -e "s:{checks_total}:$checks_total:g" \
        > "$ProgressBuffer"

        render
}

render()
{
        tput civis
        tput cup 0 0
        tput il $(tput lines) # tput ed
        cat "$MessageBuffer"
        echo
        cat "$ProgressBuffer"
        tput cnorm
}

count_lines()
{
        wc -l <<EOF | tr -d ' '
$@
EOF
}

main "$@"
