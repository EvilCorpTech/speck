#!/usr/bin/env sh

set -e ## errexit
set -u ## nounset

IFS='
'
CmdDir="$(cd "$(dirname "$0")" && pwd)"
VerboseFlag=no
DebugFlag=no
MessageBuffer="$(mktemp)"
ProgressBuffer="$(mktemp)"

: ${ResetStyle:=$(tput sgr0)}
: ${BoldStyle:=$(tput bold)}
: ${ReverseStyle:=$(tput rev)}

: ${GreenStyle:=$(tput setaf 120)}
: ${YellowStyle:=$(tput setaf 229)}
: ${RedStyle:=$(tput setaf 160)}
: ${BlueStyle:=$(tput setaf 75)}
: ${GrayStyle:=$(tput setaf 239)}

if test $(tput colors) -le 8; then
        GreenStyle="$(tput setaf 2)"
        YellowStyle="$(tput setaf 3)"
        RedStyle="$(tput setaf 1)"
        BlueStyle="$(tput setaf 4)"
        GrayStyle="$(tput setaf 8)"
fi

if test ! -t 1 -o -p /dev/stdout; then
        ## We are redirected or in a pipe.
        ResetStyle=
        ReverseStyle=
        GreenStyle=
        YellowStyle=
        RedStyle=
        BlueStyle=
        GrayStyle=
fi

ErrorStyle="$RedStyle"
WarningStyle="$YellowStyle"
SuccessStyle="$GreenStyle"
DimmedStyle="$GrayStyle"

: ${SpeckSuiteStyle:=\\n%s\\n}
: ${SpeckProgressStyle:=${ReverseStyle} suites(\{suites_count\}/\{suites_total\}) specs(\{specs_count\}/\{specs_total\}) checks(\{checks_count\}/\{checks_total\}) ${ResetStyle}}
: ${SpeckCheckProgressStyle:=          \{desc\}}
: ${SpeckCheckSuccessStyle:=    ${SuccessStyle}ok${ResetStyle}    \{desc\}}
: ${SpeckCheckErrorStyle:=  ${ErrorStyle}failed${ResetStyle}  \{desc\}}
: ${SpeckSuccessStyle:=\\n${SuccessStyle}${ReverseStyle} Success ${ResetStyle}  }
: ${SpeckErrorStyle:=\\n${ErrorStyle}${ReverseStyle} Error ${ResetStyle}  }
: ${SpeckDumpStyle:=s:^:> :}
: ${SpeckSummaryStyle:=failed(${ErrorStyle}${BoldStyle}\{errors\}${ResetStyle})  succeeded(${SuccessStyle}${BoldStyle}\{completed\}${ResetStyle})  total(${BlueStyle}${BoldStyle}\{specs\}${ResetStyle})\\n}

before_all() { :; }
before()     { :; }
after()      { :; }
after_all()  { :; }

usage()
{
        echo "Usage: $(basename "$0") [ -v,--verbose ] [ -d,--debug ] [ <file_or_dir> ... ]"
}

run_spec()
{(
        set -e

        local spec_file="$1"
        local spec_checks="$2"
        local spec_exit_status=0

        printf -- "$SpeckSuiteStyle" "${1#$CmdDir/}" \
        | output

        __specdir__="$(dirname "$1")"
        __specfile__="$1"

        . "$spec_file"

        before_all

        for spec_check in $spec_checks; do
                checks_count=$(expr $checks_count + 1)
                local spec_check_name="${spec_check%%\(*}"
                local spec_check_desc="$(printf -- '%s' "$spec_check_name" | tr '_' ' ')"

                set +e
                (
                set -e

                before

                printf -- "$SpeckCheckProgressStyle" \
                | sed -e "s:{desc}:$spec_check_desc:g" \
                | output

                set +e
                output="$(set -e; $spec_check_name 2>&1)"
                test $? -eq 0   ## Converts an exit status different from 0 to 1.
                local spec_check_exit_status=$?
                set -e

                local speck_check_style="$SpeckCheckErrorStyle"
                if test $spec_check_exit_status -eq 0; then
                        speck_check_style="$SpeckCheckSuccessStyle"
                fi

                printf -- "$(tput cuu1)$speck_check_style$(tput el)" \
                | sed -e "s:{desc}:$spec_check_desc:g" \
                | output

                if test -n "$output" -a "$VerboseFlag" = 'yes'; then
                        cat <<OUT | sed -e "$SpeckDumpStyle" | output
$output
OUT
                fi

                after

                return $spec_check_exit_status
                )

                spec_exit_status=$(expr $spec_exit_status + $? || true)
        done

        after_all

        return $spec_exit_status
)}

output()
{
        cat >> "$MessageBuffer"

        printf -- "$SpeckProgressStyle" \
        | sed -e "s:{suites_count}:$suites_count:g" \
              -e "s:{suites_total}:$suites_total:g" \
              -e "s:{specs_count}:$specs_count:g" \
              -e "s:{specs_total}:$specs_total:g" \
              -e "s:{checks_count}:$checks_count:g" \
              -e "s:{checks_total}:$checks_total:g" \
        > "$ProgressBuffer"

        render
}

render()
{
        tput civis
        tput cup 0 0
        tput il $(tput lines) # tput ed
        cat "$MessageBuffer"
        echo
        cat "$ProgressBuffer"
        tput cnorm
}

count_lines()
{
        wc -l <<EOF | tr -d ' '
$@
EOF
}

main()
{
        while test $# -gt 0; do
                case $1 in
                        -v|--verbose) VerboseFlag=yes; shift;;
                        -d|--debug)   DebugFlag=yes;   shift;;
                        -*)           usage; exit 1;;
                        --) shift;;
                esac
        done

        if test "$DebugFlag" = 'yes'; then
                set -x ## xtrace
        fi

        if test $# -eq 0; then
                set -- "$CmdDir"
        fi

        local plan=''
        local exit_status=0
        local suites_total=$#
        local specs_total=0
        local checks_total=0
        local suites_count=0
        local specs_count=0
        local checks_count=0

        for suite; do
                local specs_files="$(find -L "$suite" -type f -maxdepth 2 | grep -E '_(spec|test).sh$' | sort -n)"
                specs_total=$(expr $specs_total + $(count_lines "$specs_files") || true)

                for spec_file in $specs_files; do
                        local spec_checks="$(grep -Eo '^(it|test)[_[:alnum:]]+\(\)' "$spec_file")"
                        checks_total=$(expr $checks_total + $(count_lines "$spec_checks") || true)

                        plan="${plan}\
suite:$suite
spec:$spec_file
checks:$(printf -- '%s' "$spec_checks" | tr '\n' ' ')
" ## We need a new line at the end for 'read' to process it.
                done
        done

        local prev_suite=
        local prev_spec=
        while IFS= read -r next_suite; read -r next_spec; read -r next_checks; do
                if test "$prev_suite" != "$next_suite"; then
                        suites_count=$(expr $suites_count + 1)
                fi

                if test "$prev_spec" != "$next_spec"; then
                        specs_count=$(expr $specs_count + 1)
                fi

                local spec_file="${next_spec#*:}"
                local spec_checks="$(printf -- '%s' "${next_checks#*:}" | tr ' ' '\n')"

                set +e
                run_spec "$spec_file" "$spec_checks"
                exit_status="$(expr $exit_status + $? || true)"
                set -e

                checks_count=$(expr $checks_count + $(count_lines "$spec_checks"))

                prev_suite="$next_suite"
                prev_spec="$next_spec"
        done <<EOF
$plan
EOF

        if test $exit_status -eq 0; then
                printf -- "$SpeckSuccessStyle"
        else
                printf -- "$SpeckErrorStyle"
        fi

        printf -- "$SpeckSummaryStyle" \
        | sed -e "s:{errors}:$exit_status:g" \
              -e "s:{completed}:$(expr $checks_count - $exit_status || true):g" \
              -e "s:{specs}:$checks_count:g"

        rm -f "$MessageBuffer"
        rm -f "$ProgressBuffer"

        return $exit_status
}

main "$@"
